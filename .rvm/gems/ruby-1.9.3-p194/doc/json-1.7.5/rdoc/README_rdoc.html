<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>README - json-1.7.5 Documentation</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body class="file">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="./README_rdoc.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./JSON.html">JSON</a>
  
    <li><a href="./JSON/Ext.html">JSON::Ext</a>
  
    <li><a href="./JSON/GeneratorError.html">JSON::GeneratorError</a>
  
    <li><a href="./JSON/GenericObject.html">JSON::GenericObject</a>
  
    <li><a href="./JSON/JSONError.html">JSON::JSONError</a>
  
    <li><a href="./JSON/MissingUnicodeSupport.html">JSON::MissingUnicodeSupport</a>
  
    <li><a href="./JSON/NestingError.html">JSON::NestingError</a>
  
    <li><a href="./JSON/ParserError.html">JSON::ParserError</a>
  
    <li><a href="./JSON/Pure.html">JSON::Pure</a>
  
    <li><a href="./JSON/Pure/Generator.html">JSON::Pure::Generator</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods.html">JSON::Pure::Generator::GeneratorMethods</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/Array.html">JSON::Pure::Generator::GeneratorMethods::Array</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/FalseClass.html">JSON::Pure::Generator::GeneratorMethods::FalseClass</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/Float.html">JSON::Pure::Generator::GeneratorMethods::Float</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/Hash.html">JSON::Pure::Generator::GeneratorMethods::Hash</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/Integer.html">JSON::Pure::Generator::GeneratorMethods::Integer</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/NilClass.html">JSON::Pure::Generator::GeneratorMethods::NilClass</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/Object.html">JSON::Pure::Generator::GeneratorMethods::Object</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/String.html">JSON::Pure::Generator::GeneratorMethods::String</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/String/Extend.html">JSON::Pure::Generator::GeneratorMethods::String::Extend</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/TrueClass.html">JSON::Pure::Generator::GeneratorMethods::TrueClass</a>
  
    <li><a href="./JSON/Pure/Generator/State.html">JSON::Pure::Generator::State</a>
  
    <li><a href="./JSON/Pure/Parser.html">JSON::Pure::Parser</a>
  
    <li><a href="./JSON/GeneratorError.html">JSON::UnparserError</a>
  
    <li><a href="./BigDecimal.html">BigDecimal</a>
  
    <li><a href="./Class.html">Class</a>
  
    <li><a href="./Complex.html">Complex</a>
  
    <li><a href="./Date.html">Date</a>
  
    <li><a href="./DateTime.html">DateTime</a>
  
    <li><a href="./Exception.html">Exception</a>
  
    <li><a href="./Kernel.html">Kernel</a>
  
    <li><a href="./OpenStruct.html">OpenStruct</a>
  
    <li><a href="./Range.html">Range</a>
  
    <li><a href="./Rational.html">Rational</a>
  
    <li><a href="./Regexp.html">Regexp</a>
  
    <li><a href="./Struct.html">Struct</a>
  
    <li><a href="./Symbol.html">Symbol</a>
  
    <li><a href="./Time.html">Time</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation" class="description">
  
<h1 id="label-JSON+implementation+for+Ruby+%3Cimg+src%3D%22https%3A%2F%2Fsecure.travis-ci.org%2Fflori%2Fjson.png%22+%2F%3E"><a href="JSON.html">JSON</a> implementation for Ruby <a href="http://travis-ci.org/flori/json"><img src="https://secure.travis-ci.org/flori/json.png" /></a></h1>

<h2 id="label-Description">Description</h2>

<p>This is a implementation of the <a href="JSON.html">JSON</a> specification
according to RFC 4627 <a
href="http://www.ietf.org/rfc/rfc4627.txt">www.ietf.org/rfc/rfc4627.txt</a>
. Starting from version 1.0.0 on there will be two variants available:</p>
<ul><li>
<p>A pure ruby variant, that relies on the iconv and the stringscan
extensions, which are both part of the ruby standard library.</p>
</li><li>
<p>The quite a bit faster C extension variant, which is in parts implemented
in C and comes with its own unicode conversion functions and a parser
generated by the ragel state machine compiler <a
href="http://www.cs.queensu.ca/~thurston/ragel">www.cs.queensu.ca/~thurston/ragel</a>
.</p>
</li></ul>

<p>Both variants of the <a href="JSON.html">JSON</a> generator generate UTF-8
character sequences by default. If an :ascii_only option with a true value
is given, they escape all non-ASCII and control characters with uXXXX
escape sequences, and support UTF-16 surrogate pairs in order to be able to
generate the whole range of unicode code points.</p>

<p>All strings, that are to be encoded as <a href="JSON.html">JSON</a>
strings, should be UTF-8 byte sequences on the Ruby side. To encode raw
binary strings, that aren’t UTF-8 encoded, please use the
to_json_raw_object method of String (which produces an object, that
contains a byte array) and decode the result on the receiving endpoint.</p>

<p>The <a href="JSON.html">JSON</a> parsers can parse UTF-8, UTF-16BE,
UTF-16LE, UTF-32BE, and UTF-32LE <a href="JSON.html">JSON</a> documents
under Ruby 1.8. Under Ruby 1.9 they take advantage of Ruby’s M17n features
and can parse all documents which have the correct String#encoding set. If
a document string has ASCII-8BIT as an encoding the parser attempts to
figure out which of the UTF encodings from above it is and trys to parse
it.</p>

<h2 id="label-Installation">Installation</h2>

<p>It’s recommended to use the extension variant of <a
href="JSON.html">JSON</a>, because it’s faster than the pure ruby variant.
If you cannot build it on your system, you can settle for the latter.</p>

<p>Just type into the command line as root:</p>

<pre># rake install</pre>

<p>The above command will build the extensions and install them on your
system.</p>

<pre># rake install_pure</pre>

<p>or</p>

<pre># ruby install.rb</pre>

<p>will just install the pure ruby implementation of <a
href="JSON.html">JSON</a>.</p>

<p>If you use Rubygems you can type</p>

<pre># gem install json</pre>

<p>instead, to install the newest <a href="JSON.html">JSON</a> version.</p>

<p>There is also a pure ruby json only variant of the gem, that can be
installed with:</p>

<pre># gem install json_pure</pre>

<h2 id="label-Compiling+the+extensions+yourself">Compiling the extensions yourself</h2>

<p>If you want to build the extensions yourself you need rake:</p>

<pre>You can get it from rubyforge:
  http://rubyforge.org/projects/rake

or just type

# gem install rake

for the installation via rubygems.</pre>

<p>If you want to create the parser.c file from its parser.rl file or draw
nice graphviz images of the state machines, you need ragel from: <a
href="http://www.cs.queensu.ca/~thurston/ragel">www.cs.queensu.ca/~thurston/ragel</a></p>

<h2 id="label-Usage">Usage</h2>

<p>To use <a href="JSON.html">JSON</a> you can</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'json'</span>
</pre>

<p>to load the installed variant (either the extension ‘json’ or the pure
variant ‘json_pure’). If you have installed the extension variant, you can
pick either the extension variant or the pure variant by typing</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'json/ext'</span>
</pre>

<p>or</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'json/pure'</span>
</pre>

<p>Now you can parse a <a href="JSON.html">JSON</a> document into a ruby data
structure by calling</p>

<pre>JSON.parse(document)</pre>

<p>If you want to generate a <a href="JSON.html">JSON</a> document from a ruby
data structure call</p>

<pre>JSON.generate(data)</pre>

<p>You can also use the pretty_generate method (which formats the output more
verbosely and nicely) or fast_generate (which doesn’t do any of the
security checks generate performs, e. g. nesting deepness checks).</p>

<p>To create a valid <a href="JSON.html">JSON</a> document you have to make
sure, that the output is embedded in either a <a href="JSON.html">JSON</a>
array [] or a <a href="JSON.html">JSON</a> object {}. The easiest way to do
this, is by putting your values in a Ruby Array or Hash instance.</p>

<p>There are also the <a href="JSON.html">JSON</a> and JSON[] methods which
use parse on a String or generate a <a href="JSON.html">JSON</a> document
from an array or hash:</p>

<pre class="ruby"><span class="ruby-identifier">document</span> = <span class="ruby-constant">JSON</span> <span class="ruby-string">'test'</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-value">23</span> <span class="ruby-comment"># =&gt; &quot;{\&quot;test\&quot;:23}&quot;</span>
<span class="ruby-identifier">document</span> = <span class="ruby-constant">JSON</span>[<span class="ruby-string">'test'</span>] =<span class="ruby-operator">&gt;</span> <span class="ruby-value">23</span> <span class="ruby-comment"># =&gt; &quot;{\&quot;test\&quot;:23}&quot;</span>
</pre>

<p>and</p>

<pre class="ruby"><span class="ruby-identifier">data</span> = <span class="ruby-constant">JSON</span> <span class="ruby-string">'{&quot;test&quot;:23}'</span>  <span class="ruby-comment"># =&gt; {&quot;test&quot;=&gt;23}</span>
<span class="ruby-identifier">data</span> = <span class="ruby-constant">JSON</span>[<span class="ruby-string">'{&quot;test&quot;:23}'</span>] <span class="ruby-comment"># =&gt; {&quot;test&quot;=&gt;23}</span>
</pre>

<p>You can choose to load a set of common additions to ruby core’s objects if
you</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'json/add/core'</span>
</pre>

<p>After requiring this you can, e. g., serialise/deserialise Ruby ranges:</p>

<pre class="ruby"><span class="ruby-constant">JSON</span> <span class="ruby-constant">JSON</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>) <span class="ruby-comment"># =&gt; 1..10</span>
</pre>

<p>To find out how to add <a href="JSON.html">JSON</a> support to other or
your own classes, read the section “More Examples” below.</p>

<p>To get the best compatibility to rails’ <a href="JSON.html">JSON</a>
implementation, you can</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'json/add/rails'</span>
</pre>

<p>Both of the additions attempt to require ‘json’ (like above) first, if it
has not been required yet.</p>

<h2 id="label-More+Examples">More Examples</h2>

<p>To create a <a href="JSON.html">JSON</a> document from a ruby data
structure, you can call <a
href="JSON.html#method-i-generate">JSON#generate</a> like that:</p>

<pre class="ruby"><span class="ruby-identifier">json</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">generate</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, {<span class="ruby-string">&quot;a&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">3.141</span>}, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]
<span class="ruby-comment"># =&gt; &quot;[1,2,{\&quot;a\&quot;:3.141},false,true,null,\&quot;4..10\&quot;]&quot;</span>
</pre>

<p>To get back a ruby data structure from a <a href="JSON.html">JSON</a>
document, you have to call <a
href="JSON.html#method-i-parse">JSON#parse</a> on it:</p>

<pre class="ruby"><span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span> <span class="ruby-identifier">json</span>
<span class="ruby-comment"># =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, &quot;4..10&quot;]</span>
</pre>

<p>Note, that the range from the original data structure is a simple string
now. The reason for this is, that <a href="JSON.html">JSON</a> doesn’t
support ranges or arbitrary classes. In this case the json library falls
back to call Object#to_json, which is the same as to_s.to_json.</p>

<p>It’s possible to add <a href="JSON.html">JSON</a> support serialization to
arbitrary classes by simply implementing a more specialized version of the
to_json method, that should return a <a href="JSON.html">JSON</a> object (a
hash converted to <a href="JSON.html">JSON</a> with to_json) like this
(don’t forget the *a for all the arguments):</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Range</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">to_json</span>(*<span class="ruby-identifier">a</span>)
    {
      <span class="ruby-string">'json_class'</span>   =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>, <span class="ruby-comment"># = 'Range'</span>
      <span class="ruby-string">'data'</span>         =<span class="ruby-operator">&gt;</span> [ <span class="ruby-identifier">first</span>, <span class="ruby-identifier">last</span>, <span class="ruby-identifier">exclude_end?</span> ]
    }.<span class="ruby-identifier">to_json</span>(*<span class="ruby-identifier">a</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The hash key ‘json_class’ is the class, that will be asked to deserialise
the <a href="JSON.html">JSON</a> representation later. In this case it’s
‘Range’, but any namespace of the form ‘A::B’ or ‘::A::B’ will do. All
other keys are arbitrary and can be used to store the necessary data to
configure the object to be deserialised.</p>

<p>If a the key ‘json_class’ is found in a <a href="JSON.html">JSON</a>
object, the <a href="JSON.html">JSON</a> parser checks if the given class
responds to the json_create class method. If so, it is called with the <a
href="JSON.html">JSON</a> object converted to a Ruby hash. So a range can
be deserialised by implementing <a
href="Range.html#method-c-json_create">Range.json_create</a> like this:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Range</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">o</span>)
    <span class="ruby-identifier">new</span>(*<span class="ruby-identifier">o</span>[<span class="ruby-string">'data'</span>])
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Now it possible to serialise/deserialise ranges as well:</p>

<pre class="ruby"><span class="ruby-identifier">json</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">generate</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, {<span class="ruby-string">&quot;a&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">3.141</span>}, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]
<span class="ruby-comment"># =&gt; &quot;[1,2,{\&quot;a\&quot;:3.141},false,true,null,{\&quot;json_class\&quot;:\&quot;Range\&quot;,\&quot;data\&quot;:[4,10,false]}]&quot;</span>
<span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span> <span class="ruby-identifier">json</span>
<span class="ruby-comment"># =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]</span>
</pre>

<p><a href="JSON.html#method-i-generate">JSON#generate</a> always creates the
shortest possible string representation of a ruby data structure in one
line. This is good for data storage or network protocols, but not so good
for humans to read. Fortunately there's also <a
href="JSON.html#method-i-pretty_generate">JSON#pretty_generate</a> (or <a
href="JSON.html#method-i-pretty_generate">JSON#pretty_generate</a>) that
creates a more readable output:</p>

<pre class="ruby"><span class="ruby-identifier">puts</span> <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">pretty_generate</span>([<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, {<span class="ruby-string">&quot;a&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">3.141</span>}, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>])
[
  <span class="ruby-value">1</span>,
  <span class="ruby-value">2</span>,
  {
    <span class="ruby-string">&quot;a&quot;</span><span class="ruby-operator">:</span> <span class="ruby-value">3.141</span>
  },
  <span class="ruby-keyword">false</span>,
  <span class="ruby-keyword">true</span>,
  <span class="ruby-identifier">null</span>,
  {
    <span class="ruby-string">&quot;json_class&quot;</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;Range&quot;</span>,
    <span class="ruby-string">&quot;data&quot;</span><span class="ruby-operator">:</span> [
      <span class="ruby-value">4</span>,
      <span class="ruby-value">10</span>,
      <span class="ruby-keyword">false</span>
    ]
  }
]
</pre>

<p>There are also the methods Kernel#j for generate, and Kernel#jj for
pretty_generate output to the console, that work analogous to Core Ruby’s p
and the pp library’s pp methods.</p>

<p>The script tools/server.rb contains a small example if you want to test,
how receiving a <a href="JSON.html">JSON</a> object from a webrick server
in your browser with the javasript prototype library <a
href="http://www.prototypejs.org">www.prototypejs.org</a> works.</p>

<h2 id="label-Speed+Comparisons">Speed Comparisons</h2>

<p>I have created some benchmark results (see the benchmarks/data-p4-3Ghz
subdir of the package) for the JSON-parser to estimate the speed up in the
C extension:</p>

<pre>Comparing times (call_time_mean):
 1 ParserBenchmarkExt#parser   900 repeats:
       553.922304770 (  real) -&gt;   21.500x 
         0.001805307
 2 ParserBenchmarkYAML#parser  1000 repeats:
       224.513358139 (  real) -&gt;    8.714x 
         0.004454078
 3 ParserBenchmarkPure#parser  1000 repeats:
        26.755020642 (  real) -&gt;    1.038x 
         0.037376163
 4 ParserBenchmarkRails#parser 1000 repeats:
        25.763381731 (  real) -&gt;    1.000x 
         0.038814780
           calls/sec (  time) -&gt;    speed  covers
           secs/call</pre>

<p>In the table above 1 is JSON::Ext::Parser, 2 is YAML.load with YAML
compatbile <a href="JSON.html">JSON</a> document, 3 is is <a
href="JSON/Pure/Parser.html">JSON::Pure::Parser</a>, and 4 is
ActiveSupport::JSON.decode. The ActiveSupport JSON-decoder converts the
input first to YAML and then uses the YAML-parser, the conversion seems to
slow it down so much that it is only as fast as the <a
href="JSON/Pure/Parser.html">JSON::Pure::Parser</a>!</p>

<p>If you look at the benchmark data you can see that this is mostly caused by
the frequent high outliers - the median of the Rails-parser runs is still
overall smaller than the median of the <a
href="JSON/Pure/Parser.html">JSON::Pure::Parser</a> runs:</p>

<pre>Comparing times (call_time_median):
 1 ParserBenchmarkExt#parser   900 repeats:
       800.592479481 (  real) -&gt;   26.936x 
         0.001249075
 2 ParserBenchmarkYAML#parser  1000 repeats:
       271.002390644 (  real) -&gt;    9.118x 
         0.003690004
 3 ParserBenchmarkRails#parser 1000 repeats:
        30.227910865 (  real) -&gt;    1.017x 
         0.033082008
 4 ParserBenchmarkPure#parser  1000 repeats:
        29.722384421 (  real) -&gt;    1.000x 
         0.033644676
           calls/sec (  time) -&gt;    speed  covers
           secs/call</pre>

<p>I have benchmarked the JSON-Generator as well. This generated a few more
values, because there are different modes that also influence the achieved
speed:</p>

<pre>Comparing times (call_time_mean):
 1 GeneratorBenchmarkExt#generator_fast    1000 repeats:
       547.354332608 (  real) -&gt;   15.090x 
         0.001826970
 2 GeneratorBenchmarkExt#generator_safe    1000 repeats:
       443.968212317 (  real) -&gt;   12.240x 
         0.002252414
 3 GeneratorBenchmarkExt#generator_pretty  900 repeats:
       375.104545883 (  real) -&gt;   10.341x 
         0.002665923
 4 GeneratorBenchmarkPure#generator_fast   1000 repeats:
        49.978706968 (  real) -&gt;    1.378x 
         0.020008521
 5 GeneratorBenchmarkRails#generator       1000 repeats:
        38.531868759 (  real) -&gt;    1.062x 
         0.025952543
 6 GeneratorBenchmarkPure#generator_safe   1000 repeats:
        36.927649925 (  real) -&gt;    1.018x 7 (&gt;=3859)
         0.027079979
 7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:
        36.272134441 (  real) -&gt;    1.000x 6 (&gt;=3859)
         0.027569373
           calls/sec (  time) -&gt;    speed  covers
           secs/call</pre>

<p>In the table above 1-3 are JSON::Ext::Generator methods. 4, 6, and 7 are <a
href="JSON/Pure/Generator.html">JSON::Pure::Generator</a> methods and 5 is
the Rails <a href="JSON.html">JSON</a> generator. It is now a bit faster
than the generator_safe and generator_pretty methods of the pure variant
but slower than the others.</p>

<p>To achieve the fastest <a href="JSON.html">JSON</a> document output, you
can use the fast_generate method. Beware, that this will disable the
checking for circular Ruby data structures, which may cause <a
href="JSON.html">JSON</a> to go into an infinite loop.</p>

<p>Here are the median comparisons for completeness’ sake:</p>

<pre>Comparing times (call_time_median):
 1 GeneratorBenchmarkExt#generator_fast    1000 repeats:
       708.258020939 (  real) -&gt;   16.547x 
         0.001411915
 2 GeneratorBenchmarkExt#generator_safe    1000 repeats:
       569.105020353 (  real) -&gt;   13.296x 
         0.001757145
 3 GeneratorBenchmarkExt#generator_pretty  900 repeats:
       482.825371244 (  real) -&gt;   11.280x 
         0.002071142
 4 GeneratorBenchmarkPure#generator_fast   1000 repeats:
        62.717626652 (  real) -&gt;    1.465x 
         0.015944481
 5 GeneratorBenchmarkRails#generator       1000 repeats:
        43.965681162 (  real) -&gt;    1.027x 
         0.022745013
 6 GeneratorBenchmarkPure#generator_safe   1000 repeats:
        43.929073409 (  real) -&gt;    1.026x 7 (&gt;=3859)
         0.022763968
 7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:
        42.802514491 (  real) -&gt;    1.000x 6 (&gt;=3859)
         0.023363113
           calls/sec (  time) -&gt;    speed  covers
           secs/call</pre>

<h2 id="label-Author">Author</h2>

<p>Florian Frank &lt;<a href="mailto:flori@ping.de">flori@ping.de</a>&gt;</p>

<h2 id="label-License">License</h2>

<p>Ruby License, see the COPYING file included in the source distribution. The
Ruby License includes the GNU General Public License (GPL), Version 2, so
see the file GPL as well.</p>

<h2 id="label-Download">Download</h2>

<p>The latest version of this library can be downloaded at</p>
<ul><li>
<p><a
href="http://rubyforge.org/frs?group_id=953">rubyforge.org/frs?group_id=953</a></p>
</li></ul>

<p>Online Documentation should be located at</p>
<ul><li>
<p><a href="http://json.rubyforge.org">json.rubyforge.org</a></p>
</li></ul>

</div>



<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

