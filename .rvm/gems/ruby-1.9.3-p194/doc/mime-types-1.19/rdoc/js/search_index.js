var search_data = {"index":{"searchIndex":["mime","invalidcontenttype","type","types","<=>()","[]()","[]()","add()","add()","ascii?()","binary?()","complete?()","docs=()","eql?()","from_array()","from_hash()","from_mime_type()","like?()","new()","new()","obsolete?()","of()","of()","platform?()","priority_compare()","registered?()","signature?()","simplified()","system?()","to_a()","to_hash()","to_s()","to_str()","type_for()","type_for()","urls()","history","licence","manifest","readme","application","audio","image","message","model","multipart","text","video"],"longSearchIndex":["mime","mime::invalidcontenttype","mime::type","mime::types","mime::type#<=>()","mime::types#[]()","mime::types::[]()","mime::types::add()","mime::types#add()","mime::type#ascii?()","mime::type#binary?()","mime::type#complete?()","mime::type#docs=()","mime::type#eql?()","mime::type::from_array()","mime::type::from_hash()","mime::type::from_mime_type()","mime::type#like?()","mime::type::new()","mime::types::new()","mime::type#obsolete?()","mime::types::of()","mime::types#of()","mime::type#platform?()","mime::type#priority_compare()","mime::type#registered?()","mime::type#signature?()","mime::type::simplified()","mime::type#system?()","mime::type#to_a()","mime::type#to_hash()","mime::type#to_s()","mime::type#to_str()","mime::types#type_for()","mime::types::type_for()","mime::type#urls()","","","","","","","","","","","",""],"info":[["MIME","","MIME.html","","<p>The namespace for MIME applications, tools, and libraries.\n"],["MIME::InvalidContentType","","MIME/InvalidContentType.html","","<p>Reflects a MIME Content-Type which is in invalid format (e.g., it isn’t in\nthe form of type/subtype). …\n"],["MIME::Type","","MIME/Type.html","","<p>The definition of one MIME content-type.\n<p>Usage\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">'mime/types'</span>\n\n<span class=\"ruby-identifier\">plaintext</span> = <span class=\"ruby-constant\">MIME</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Types</span>[<span class=\"ruby-string\">'text/plain'</span>] <span class=\"ruby-operator\">...</span>\n</pre>\n"],["MIME::Types","","MIME/Types.html","","<p>MIME::Types\n<p>MIME types are used in MIME-compliant communications, as in e-mail or HTTP\ntraffic, to indicate …\n"],["<=>","MIME::Type","MIME/Type.html#method-i-3C-3D-3E","(other)","<p>Compares the MIME::Type against the exact content type or the simplified\ntype (the simplified type will …\n"],["[]","MIME::Types","MIME/Types.html#method-i-5B-5D","(type_id, flags = {})","<p>Returns a list of MIME::Type objects, which may be empty. The optional flag\nparameters are :complete …\n"],["[]","MIME::Types","MIME/Types.html#method-c-5B-5D","(type_id, flags = {})","<p>Returns a list of MIME::Type objects, which may be empty. The optional flag\nparameters are :complete …\n"],["add","MIME::Types","MIME/Types.html#method-c-add","(*types)","<p>Add one or more MIME::Type objects to the set of known types. Each type\nshould be experimental (e.g. …\n"],["add","MIME::Types","MIME/Types.html#method-i-add","(*types)","<p>Add one or more MIME::Type objects to the set of known types. Each type\nshould be experimental (e.g. …\n"],["ascii?","MIME::Type","MIME/Type.html#method-i-ascii-3F","()","<p>MIME types can be specified to be sent across a network in particular\nformats. This method returns <code>false</code> …\n"],["binary?","MIME::Type","MIME/Type.html#method-i-binary-3F","()","<p>MIME types can be specified to be sent across a network in particular\nformats. This method returns <code>true</code> …\n"],["complete?","MIME::Type","MIME/Type.html#method-i-complete-3F","()","<p>Returns <code>true</code> if the MIME::Type specifies an extension list,\nindicating that it is a complete MIME::Type …\n"],["docs=","MIME::Type","MIME/Type.html#method-i-docs-3D","(d)",""],["eql?","MIME::Type","MIME/Type.html#method-i-eql-3F","(other)","<p>Returns <code>true</code> if the other object is a MIME::Type and the\ncontent types match.\n"],["from_array","MIME::Type","MIME/Type.html#method-c-from_array","(*args)","<p>Creates a MIME::Type from an array in the form of:\n\n<pre>[type-name, [extensions], encoding, system]</pre>\n<p><code>extensions</code> ...\n"],["from_hash","MIME::Type","MIME/Type.html#method-c-from_hash","(hash)","<p>Creates a MIME::Type from a hash. Keys are case-insensitive, dashes may be\nreplaced with underscores, …\n"],["from_mime_type","MIME::Type","MIME/Type.html#method-c-from_mime_type","(mime_type)","<p>Essentially a copy constructor.\n\n<pre>MIME::Type.from_mime_type(plaintext)</pre>\n<p>is equivalent to:\n"],["like?","MIME::Type","MIME/Type.html#method-i-like-3F","(other)","<p>Returns <code>true</code> if the simplified type matches the current\n"],["new","MIME::Type","MIME/Type.html#method-c-new","(content_type)","<p>Builds a MIME::Type object from the provided MIME Content Type value (e.g.,\n‘text/plain’ or ‘applicaton/x-eruby …\n"],["new","MIME::Types","MIME/Types.html#method-c-new","(data_version = nil)",""],["obsolete?","MIME::Type","MIME/Type.html#method-i-obsolete-3F","()","<p>Returns <code>true</code> if the media type is obsolete.\n"],["of","MIME::Types","MIME/Types.html#method-c-of","(filename, platform = false)","<p>A synonym for MIME::Types.type_for\n"],["of","MIME::Types","MIME/Types.html#method-i-of","(filename, platform = false)","<p>A synonym for MIME::Types.type_for\n"],["platform?","MIME::Type","MIME/Type.html#method-i-platform-3F","()","<p>Returns <code>true</code> if the MIME::Type is specific to the current\noperating system as represented by RUBY_PLATFORM …\n"],["priority_compare","MIME::Type","MIME/Type.html#method-i-priority_compare","(other)","<p>Compares the MIME::Type based on how reliable it is before doing a normal\n&lt;=&gt; comparison. Used …\n"],["registered?","MIME::Type","MIME/Type.html#method-i-registered-3F","()","<p>MIME content-types which are not regestered by IANA nor defined in RFCs are\nrequired to start with <code>x-</code> …\n"],["signature?","MIME::Type","MIME/Type.html#method-i-signature-3F","()","<p>Returns <code>true</code> when the simplified MIME type is in the list of\nknown digital signatures.\n"],["simplified","MIME::Type","MIME/Type.html#method-c-simplified","(content_type)","<p>The MIME types main- and sub-label can both start with <code>x-</code>,\nwhich indicates that it is a non-registered …\n"],["system?","MIME::Type","MIME/Type.html#method-i-system-3F","()","<p>Returns <code>true</code> if the MIME::Type is specific to an operating\nsystem.\n"],["to_a","MIME::Type","MIME/Type.html#method-i-to_a","()","<p>Returns the MIME type as an array suitable for use with\nMIME::Type.from_array.\n"],["to_hash","MIME::Type","MIME/Type.html#method-i-to_hash","()","<p>Returns the MIME type as an array suitable for use with\nMIME::Type.from_hash.\n"],["to_s","MIME::Type","MIME/Type.html#method-i-to_s","()","<p>Returns the MIME type as a string.\n"],["to_str","MIME::Type","MIME/Type.html#method-i-to_str","()","<p>Returns the MIME type as a string for implicit conversions.\n"],["type_for","MIME::Types","MIME/Types.html#method-i-type_for","(filename, platform = false)","<p>Return the list of MIME::Types which belongs to the file based on its\nfilename extension. If <code>platform</code> …\n"],["type_for","MIME::Types","MIME/Types.html#method-c-type_for","(filename, platform = false)","<p>Return the list of MIME::Types which belongs to the file based on its\nfilename extension. If <code>platform</code> …\n"],["urls","MIME::Type","MIME/Type.html#method-i-urls","()","<p>The decoded URL list for this MIME::Type. The special URL value IANA will\nbe translated into:\n\n<pre>http://www.iana.org/assignments/media-types/&lt;mediatype&gt;/&lt;subtype&gt;</pre>\n"],["History","","History_rdoc.html","","<p>1.19 / 2012-06-20\n<p>New MIME Types:\n<p>XCF Gnome Images (image/x-xcf, image/x-compressed-xcf; .xcf).\ngithub.com/halostatue/mime-types/issue/17 …\n"],["Licence","","Licence_rdoc.html","","<p>Licence\n<p>This software is available under a triple disjunctive licence: Ruby’s\nlicence, the Perl Artistic …\n"],["Manifest","","Manifest_txt.html","","<p>History.rdoc Licence.rdoc Manifest.txt README.rdoc Rakefile\nlib/mime/types.rb lib/mime/types/application …\n"],["README","","README_rdoc.html","","<p>MIME::Types for Ruby\n<p>home  &mdash; mime-types.rubyforge.org/\n<p>code  &mdash; github.com/halostatue/mime-types/\n"],["application","","lib/mime/types/application.html","","<p>application/1d-interleaved-parityfec ‘IANA,RFC6015 application/3gpp-ims+xml\n’IANA, application/CSTAdata …\n"],["audio","","lib/mime/types/audio.html","","<p>audio/1d-interleaved-parityfec ‘IANA,RFC6015 audio/32kadpcm\n’IANA,RFC3802,RFC2421 audio/3gpp ‘IANA,RFC3839 …\n"],["image","","lib/mime/types/image.html","","<p>image/cgm ‘IANA, image/example ’IANA,RFC4735 image/fits ‘IANA,RFC4047\nimage/g3fax ’IANA,RFC1494 image/gif …\n"],["message","","lib/mime/types/message.html","","<p>message/CPIM ‘IANA,RFC3862 message/delivery-status ’IANA,RFC1894\nmessage/disposition-notification ‘IANA …\n"],["model","","lib/mime/types/model.html","","<p>model/example ‘IANA,RFC4735 model/iges @igs,iges ’IANA, model/mesh\n@msh,mesh,silo ‘IANA,RFC2077 model/vnd.dwf …\n"],["multipart","","lib/mime/types/multipart.html","","<p>multipart/alternative :8bit ‘IANA,RFC2045,RFC2046 multipart/appledouble\n:8bit ’IANA, multipart/byteranges …\n"],["text","","lib/mime/types/text.html","","<p>text/1d-interleaved-parityfec ‘IANA,RFC6015 text/RED ’IANA,RFC4102\ntext/calendar ‘IANA,RFC5545 text/css …\n"],["video","","lib/mime/types/video.html","","<p>video/1d-interleaved-parityfec ‘IANA,RFC6015 video/3gpp @3gp,3gpp\n’IANA,RFC3839,RFC6381 video/3gpp-tt …\n"]]}}