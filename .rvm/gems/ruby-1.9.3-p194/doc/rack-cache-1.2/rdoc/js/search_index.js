var search_data = {"index":{"searchIndex":["rack","cache","appengine","mc","memcache","cachecontrol","context","entitystore","disk","dalli","disk","file","gae","gaecache","gaestore","heap","heap","mem","memcachebase","memcached","key","metastore","disk","dalli","disk","file","gae","gaecache","gaestore","heap","heap","mem","memcachebase","memcached","options","request","response","storage","age()","body_path()","body_path()","body_path()","cache_control()","cache_control()","cache_control=()","cache_key()","cacheable?()","call()","call()","call!()","clear()","client_ttl=()","contains?()","date()","delete()","entitystore()","etag()","exist?()","exist?()","exist?()","exist?()","exist?()","exist?()","exist?()","exist?()","exist?()","exist?()","exist?()","expire!()","expires()","fresh?()","generate()","get()","initialize_copy()","instance()","invalidate()","last_modified()","lookup()","max_age()","max_age()","max_age=()","metastore()","must_revalidate?()","must_revalidate?()","namespace()","namespace=()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","no_cache?()","no_cache?()","no_store?()","not_modified!()","open()","open()","open()","open()","open()","open()","open()","open()","open()","open()","option_accessor()","option_name()","options()","options=()","private=()","private?()","proxy_revalidate?()","public?()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","purge()","put()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","read()","request_method()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve()","resolve_entitystore_uri()","resolve_metastore_uri()","s_maxage()","set()","shared_max_age()","shared_max_age=()","spread()","spread()","spread()","storage_path()","storage_path()","storage_path()","store()","to_a()","to_hash()","to_hash()","to_hash()","to_s()","ttl()","ttl=()","validateable?()","vary()","vary?()","vary_header_names()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","changes","copying","readme","todo"],"longSearchIndex":["rack","rack::cache","rack::cache::appengine","rack::cache::appengine::mc","rack::cache::appengine::memcache","rack::cache::cachecontrol","rack::cache::context","rack::cache::entitystore","rack::cache::entitystore::disk","rack::cache::entitystore::dalli","rack::cache::entitystore::disk","rack::cache::entitystore::file","rack::cache::entitystore::gae","rack::cache::entitystore::gaecache","rack::cache::entitystore::gaestore","rack::cache::entitystore::heap","rack::cache::entitystore::heap","rack::cache::entitystore::mem","rack::cache::entitystore::memcachebase","rack::cache::entitystore::memcached","rack::cache::key","rack::cache::metastore","rack::cache::metastore::disk","rack::cache::metastore::dalli","rack::cache::metastore::disk","rack::cache::metastore::file","rack::cache::metastore::gae","rack::cache::metastore::gaecache","rack::cache::metastore::gaestore","rack::cache::metastore::heap","rack::cache::metastore::heap","rack::cache::metastore::mem","rack::cache::metastore::memcachebase","rack::cache::metastore::memcached","rack::cache::options","rack::cache::request","rack::cache::response","rack::cache::storage","rack::cache::response#age()","rack::cache::entitystore::disk#body_path()","rack::cache::entitystore::disk#body_path()","rack::cache::entitystore::disk#body_path()","rack::cache::request#cache_control()","rack::cache::response#cache_control()","rack::cache::response#cache_control=()","rack::cache::metastore#cache_key()","rack::cache::response#cacheable?()","rack::cache::context#call()","rack::cache::key::call()","rack::cache::context#call!()","rack::cache::storage#clear()","rack::cache::response#client_ttl=()","rack::cache::appengine::memcache#contains?()","rack::cache::response#date()","rack::cache::appengine::memcache#delete()","rack::cache::context#entitystore()","rack::cache::response#etag()","rack::cache::entitystore::dalli#exist?()","rack::cache::entitystore::disk#exist?()","rack::cache::entitystore::disk#exist?()","rack::cache::entitystore::disk#exist?()","rack::cache::entitystore::gaestore#exist?()","rack::cache::entitystore::gaestore#exist?()","rack::cache::entitystore::gaestore#exist?()","rack::cache::entitystore::heap#exist?()","rack::cache::entitystore::heap#exist?()","rack::cache::entitystore::heap#exist?()","rack::cache::entitystore::memcached#exist?()","rack::cache::response#expire!()","rack::cache::response#expires()","rack::cache::response#fresh?()","rack::cache::key#generate()","rack::cache::appengine::memcache#get()","rack::cache::response#initialize_copy()","rack::cache::storage::instance()","rack::cache::metastore#invalidate()","rack::cache::response#last_modified()","rack::cache::metastore#lookup()","rack::cache::cachecontrol#max_age()","rack::cache::response#max_age()","rack::cache::response#max_age=()","rack::cache::context#metastore()","rack::cache::cachecontrol#must_revalidate?()","rack::cache::response#must_revalidate?()","rack::cache::appengine::memcache#namespace()","rack::cache::appengine::memcache#namespace=()","rack::cache::new()","rack::cache::appengine::memcache::new()","rack::cache::cachecontrol::new()","rack::cache::context::new()","rack::cache::entitystore::dalli::new()","rack::cache::entitystore::disk::new()","rack::cache::entitystore::disk::new()","rack::cache::entitystore::disk::new()","rack::cache::entitystore::gaestore::new()","rack::cache::entitystore::gaestore::new()","rack::cache::entitystore::gaestore::new()","rack::cache::entitystore::heap::new()","rack::cache::entitystore::heap::new()","rack::cache::entitystore::heap::new()","rack::cache::entitystore::memcached::new()","rack::cache::key::new()","rack::cache::metastore::dalli::new()","rack::cache::metastore::disk::new()","rack::cache::metastore::disk::new()","rack::cache::metastore::disk::new()","rack::cache::metastore::gaestore::new()","rack::cache::metastore::gaestore::new()","rack::cache::metastore::gaestore::new()","rack::cache::metastore::heap::new()","rack::cache::metastore::heap::new()","rack::cache::metastore::heap::new()","rack::cache::metastore::memcached::new()","rack::cache::response::new()","rack::cache::storage::new()","rack::cache::cachecontrol#no_cache?()","rack::cache::request#no_cache?()","rack::cache::cachecontrol#no_store?()","rack::cache::response#not_modified!()","rack::cache::entitystore::disk#open()","rack::cache::entitystore::disk#open()","rack::cache::entitystore::disk#open()","rack::cache::entitystore::gaestore#open()","rack::cache::entitystore::gaestore#open()","rack::cache::entitystore::gaestore#open()","rack::cache::entitystore::heap#open()","rack::cache::entitystore::heap#open()","rack::cache::entitystore::heap#open()","rack::cache::entitystore::memcachebase#open()","rack::cache::options::option_accessor()","rack::cache::options::option_name()","rack::cache::options#options()","rack::cache::options#options=()","rack::cache::response#private=()","rack::cache::cachecontrol#private?()","rack::cache::cachecontrol#proxy_revalidate?()","rack::cache::cachecontrol#public?()","rack::cache::entitystore::dalli#purge()","rack::cache::entitystore::disk#purge()","rack::cache::entitystore::disk#purge()","rack::cache::entitystore::disk#purge()","rack::cache::entitystore::gaestore#purge()","rack::cache::entitystore::gaestore#purge()","rack::cache::entitystore::gaestore#purge()","rack::cache::entitystore::heap#purge()","rack::cache::entitystore::heap#purge()","rack::cache::entitystore::heap#purge()","rack::cache::entitystore::memcached#purge()","rack::cache::metastore#purge()","rack::cache::metastore::dalli#purge()","rack::cache::metastore::disk#purge()","rack::cache::metastore::disk#purge()","rack::cache::metastore::disk#purge()","rack::cache::metastore::gaestore#purge()","rack::cache::metastore::gaestore#purge()","rack::cache::metastore::gaestore#purge()","rack::cache::metastore::heap#purge()","rack::cache::metastore::heap#purge()","rack::cache::metastore::heap#purge()","rack::cache::metastore::memcached#purge()","rack::cache::appengine::memcache#put()","rack::cache::entitystore::dalli#read()","rack::cache::entitystore::disk#read()","rack::cache::entitystore::disk#read()","rack::cache::entitystore::disk#read()","rack::cache::entitystore::gaestore#read()","rack::cache::entitystore::gaestore#read()","rack::cache::entitystore::gaestore#read()","rack::cache::entitystore::heap#read()","rack::cache::entitystore::heap#read()","rack::cache::entitystore::heap#read()","rack::cache::entitystore::memcached#read()","rack::cache::metastore#read()","rack::cache::metastore::dalli#read()","rack::cache::metastore::disk#read()","rack::cache::metastore::disk#read()","rack::cache::metastore::disk#read()","rack::cache::metastore::gaestore#read()","rack::cache::metastore::gaestore#read()","rack::cache::metastore::gaestore#read()","rack::cache::metastore::heap#read()","rack::cache::metastore::heap#read()","rack::cache::metastore::heap#read()","rack::cache::metastore::memcached#read()","rack::cache::request#request_method()","rack::cache::entitystore::disk::resolve()","rack::cache::entitystore::disk::resolve()","rack::cache::entitystore::disk::resolve()","rack::cache::entitystore::gaestore::resolve()","rack::cache::entitystore::gaestore::resolve()","rack::cache::entitystore::gaestore::resolve()","rack::cache::entitystore::heap::resolve()","rack::cache::entitystore::heap::resolve()","rack::cache::entitystore::heap::resolve()","rack::cache::entitystore::memcachebase::resolve()","rack::cache::metastore::disk::resolve()","rack::cache::metastore::disk::resolve()","rack::cache::metastore::disk::resolve()","rack::cache::metastore::gaestore::resolve()","rack::cache::metastore::gaestore::resolve()","rack::cache::metastore::gaestore::resolve()","rack::cache::metastore::heap::resolve()","rack::cache::metastore::heap::resolve()","rack::cache::metastore::heap::resolve()","rack::cache::metastore::memcachebase::resolve()","rack::cache::storage#resolve_entitystore_uri()","rack::cache::storage#resolve_metastore_uri()","rack::cache::cachecontrol#s_maxage()","rack::cache::options#set()","rack::cache::cachecontrol#shared_max_age()","rack::cache::response#shared_max_age=()","rack::cache::entitystore::disk#spread()","rack::cache::entitystore::disk#spread()","rack::cache::entitystore::disk#spread()","rack::cache::entitystore::disk#storage_path()","rack::cache::entitystore::disk#storage_path()","rack::cache::entitystore::disk#storage_path()","rack::cache::metastore#store()","rack::cache::response#to_a()","rack::cache::metastore::heap#to_hash()","rack::cache::metastore::heap#to_hash()","rack::cache::metastore::heap#to_hash()","rack::cache::cachecontrol#to_s()","rack::cache::response#ttl()","rack::cache::response#ttl=()","rack::cache::response#validateable?()","rack::cache::response#vary()","rack::cache::response#vary?()","rack::cache::response#vary_header_names()","rack::cache::entitystore::dalli#write()","rack::cache::entitystore::disk#write()","rack::cache::entitystore::disk#write()","rack::cache::entitystore::disk#write()","rack::cache::entitystore::gaestore#write()","rack::cache::entitystore::gaestore#write()","rack::cache::entitystore::gaestore#write()","rack::cache::entitystore::heap#write()","rack::cache::entitystore::heap#write()","rack::cache::entitystore::heap#write()","rack::cache::entitystore::memcached#write()","rack::cache::metastore#write()","rack::cache::metastore::dalli#write()","rack::cache::metastore::disk#write()","rack::cache::metastore::disk#write()","rack::cache::metastore::disk#write()","rack::cache::metastore::gaestore#write()","rack::cache::metastore::gaestore#write()","rack::cache::metastore::gaestore#write()","rack::cache::metastore::heap#write()","rack::cache::metastore::heap#write()","rack::cache::metastore::heap#write()","rack::cache::metastore::memcached#write()","","","",""],"info":[["Rack","","Rack.html","",""],["Rack::Cache","","Rack/Cache.html","","<p>HTTP Caching For Rack\n<p>Rack::Cache is suitable as a quick, drop-in component to enable HTTP\ncaching for …\n"],["Rack::Cache::AppEngine","","Rack/Cache/AppEngine.html","",""],["Rack::Cache::AppEngine::MC","","Rack/Cache/AppEngine/MC.html","",""],["Rack::Cache::AppEngine::MemCache","","Rack/Cache/AppEngine/MemCache.html","",""],["Rack::Cache::CacheControl","","Rack/Cache/CacheControl.html","","<p>Parses a Cache-Control header and exposes the directives as a Hash.\nDirectives that do not have values …\n"],["Rack::Cache::Context","","Rack/Cache/Context.html","","<p>Implements Rack’s middleware interface and provides the context for all\ncache logic, including the core …\n"],["Rack::Cache::EntityStore","","Rack/Cache/EntityStore.html","","<p>Entity stores are used to cache response bodies across requests. All\nImplementations are required to …\n"],["Rack::Cache::EntityStore::DISK","","Rack/Cache/EntityStore/Disk.html","","<p>Stores entity bodies on disk at the specified path.\n"],["Rack::Cache::EntityStore::Dalli","","Rack/Cache/EntityStore/Dalli.html","","<p>Uses the Dalli ruby library. This is the default unless the memcached\nlibrary has already been required. …\n"],["Rack::Cache::EntityStore::Disk","","Rack/Cache/EntityStore/Disk.html","","<p>Stores entity bodies on disk at the specified path.\n"],["Rack::Cache::EntityStore::FILE","","Rack/Cache/EntityStore/Disk.html","","<p>Stores entity bodies on disk at the specified path.\n"],["Rack::Cache::EntityStore::GAE","","Rack/Cache/EntityStore/GAEStore.html","",""],["Rack::Cache::EntityStore::GAECACHE","","Rack/Cache/EntityStore/GAEStore.html","",""],["Rack::Cache::EntityStore::GAEStore","","Rack/Cache/EntityStore/GAEStore.html","",""],["Rack::Cache::EntityStore::HEAP","","Rack/Cache/EntityStore/Heap.html","","<p>Stores entity bodies on the heap using a Hash object.\n"],["Rack::Cache::EntityStore::Heap","","Rack/Cache/EntityStore/Heap.html","","<p>Stores entity bodies on the heap using a Hash object.\n"],["Rack::Cache::EntityStore::MEM","","Rack/Cache/EntityStore/Heap.html","","<p>Stores entity bodies on the heap using a Hash object.\n"],["Rack::Cache::EntityStore::MemCacheBase","","Rack/Cache/EntityStore/MemCacheBase.html","","<p>Base class for memcached entity stores.\n"],["Rack::Cache::EntityStore::MemCached","","Rack/Cache/EntityStore/MemCached.html","","<p>Uses the memcached client library. The ruby based memcache-client is used\nin preference to this store …\n"],["Rack::Cache::Key","","Rack/Cache/Key.html","",""],["Rack::Cache::MetaStore","","Rack/Cache/MetaStore.html","","<p>The MetaStore is responsible for storing meta information about a\nrequest/response pair keyed by the …\n"],["Rack::Cache::MetaStore::DISK","","Rack/Cache/MetaStore/Disk.html","","<p>Concrete MetaStore implementation that stores request/response pairs on\ndisk.\n"],["Rack::Cache::MetaStore::Dalli","","Rack/Cache/MetaStore/Dalli.html","",""],["Rack::Cache::MetaStore::Disk","","Rack/Cache/MetaStore/Disk.html","","<p>Concrete MetaStore implementation that stores request/response pairs on\ndisk.\n"],["Rack::Cache::MetaStore::FILE","","Rack/Cache/MetaStore/Disk.html","","<p>Concrete MetaStore implementation that stores request/response pairs on\ndisk.\n"],["Rack::Cache::MetaStore::GAE","","Rack/Cache/MetaStore/GAEStore.html","",""],["Rack::Cache::MetaStore::GAECACHE","","Rack/Cache/MetaStore/GAEStore.html","",""],["Rack::Cache::MetaStore::GAEStore","","Rack/Cache/MetaStore/GAEStore.html","",""],["Rack::Cache::MetaStore::HEAP","","Rack/Cache/MetaStore/Heap.html","","<p>Concrete MetaStore implementation that uses a simple Hash to store\nrequest/response pairs on the heap. …\n"],["Rack::Cache::MetaStore::Heap","","Rack/Cache/MetaStore/Heap.html","","<p>Concrete MetaStore implementation that uses a simple Hash to store\nrequest/response pairs on the heap. …\n"],["Rack::Cache::MetaStore::MEM","","Rack/Cache/MetaStore/Heap.html","","<p>Concrete MetaStore implementation that uses a simple Hash to store\nrequest/response pairs on the heap. …\n"],["Rack::Cache::MetaStore::MemCacheBase","","Rack/Cache/MetaStore/MemCacheBase.html","","<p>Stores request/response pairs in memcached. Keys are not stored directly\nsince memcached has a 250-byte …\n"],["Rack::Cache::MetaStore::MemCached","","Rack/Cache/MetaStore/MemCached.html","",""],["Rack::Cache::Options","","Rack/Cache/Options.html","","<p>Configuration options and utility methods for option access. Rack::Cache\nuses the Rack Environment to …\n"],["Rack::Cache::Request","","Rack/Cache/Request.html","","<p>Provides access to the HTTP request. The <code>request</code> and\n<code>original_request</code> objects exposed by the Core caching …\n"],["Rack::Cache::Response","","Rack/Cache/Response.html","","<p>Provides access to the response generated by the downstream application.\nThe <code>response</code>, <code>original_response</code> …\n"],["Rack::Cache::Storage","","Rack/Cache/Storage.html","","<p>Maintains a collection of MetaStore and EntityStore instances keyed by URI.\nA single instance of this …\n"],["age","Rack::Cache::Response","Rack/Cache/Response.html#method-i-age","()","<p>The age of the response.\n"],["body_path","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-body_path","(key)",""],["body_path","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-body_path","(key)",""],["body_path","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-body_path","(key)",""],["cache_control","Rack::Cache::Request","Rack/Cache/Request.html#method-i-cache_control","()","<p>A CacheControl instance based on the request’s Cache-Control header.\n"],["cache_control","Rack::Cache::Response","Rack/Cache/Response.html#method-i-cache_control","()","<p>A Hash of name=value pairs that correspond to the Cache-Control header.\nValueless parameters (e.g., must-revalidate, …\n"],["cache_control=","Rack::Cache::Response","Rack/Cache/Response.html#method-i-cache_control-3D","(value)","<p>Set the Cache-Control header to the values specified by the Hash. See the\n#cache_control method for information …\n"],["cache_key","Rack::Cache::MetaStore","Rack/Cache/MetaStore.html#method-i-cache_key","(request)","<p>Generate a cache key for the request.\n"],["cacheable?","Rack::Cache::Response","Rack/Cache/Response.html#method-i-cacheable-3F","()","<p>Determine if the response is worth caching under any circumstance.\nResponses marked “private” …\n"],["call","Rack::Cache::Context","Rack/Cache/Context.html#method-i-call","(env)","<p>The Rack call interface. The receiver acts as a prototype and runs each\nrequest in a dup object unless …\n"],["call","Rack::Cache::Key","Rack/Cache/Key.html#method-c-call","(request)","<p>Implement .call, since it seems like the “Rack-y” thing to do. Plus, it\nopens the door for …\n"],["call!","Rack::Cache::Context","Rack/Cache/Context.html#method-i-call-21","(env)","<p>The real Rack call interface. The caching logic is performed within the\ncontext of the receiver.\n"],["clear","Rack::Cache::Storage","Rack/Cache/Storage.html#method-i-clear","()",""],["client_ttl=","Rack::Cache::Response","Rack/Cache/Response.html#method-i-client_ttl-3D","(seconds)","<p>Set the response’s time-to-live for private/client caches. This adjusts the\nCache-Control/max-age directive. …\n"],["contains?","Rack::Cache::AppEngine::MemCache","Rack/Cache/AppEngine/MemCache.html#method-i-contains-3F","(key)",""],["date","Rack::Cache::Response","Rack/Cache/Response.html#method-i-date","()","<p>The date, as specified by the Date header. When no Date header is present,\nset the Date header to Time.now …\n"],["delete","Rack::Cache::AppEngine::MemCache","Rack/Cache/AppEngine/MemCache.html#method-i-delete","(key)",""],["entitystore","Rack::Cache::Context","Rack/Cache/Context.html#method-i-entitystore","()","<p>The configured EntityStore instance. Changing the rack-cache.entitystore\nvalue effects the result of …\n"],["etag","Rack::Cache::Response","Rack/Cache/Response.html#method-i-etag","()","<p>The literal value of ETag HTTP header or nil if no ETag is specified.\n"],["exist?","Rack::Cache::EntityStore::Dalli","Rack/Cache/EntityStore/Dalli.html#method-i-exist-3F","(key)",""],["exist?","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-exist-3F","(key)",""],["exist?","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-exist-3F","(key)",""],["exist?","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-exist-3F","(key)",""],["exist?","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-exist-3F","(key)",""],["exist?","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-exist-3F","(key)",""],["exist?","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-exist-3F","(key)",""],["exist?","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-exist-3F","(key)","<p>Determine whether the response body with the specified key (SHA1) exists in\nthe store.\n"],["exist?","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-exist-3F","(key)","<p>Determine whether the response body with the specified key (SHA1) exists in\nthe store.\n"],["exist?","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-exist-3F","(key)","<p>Determine whether the response body with the specified key (SHA1) exists in\nthe store.\n"],["exist?","Rack::Cache::EntityStore::MemCached","Rack/Cache/EntityStore/MemCached.html#method-i-exist-3F","(key)",""],["expire!","Rack::Cache::Response","Rack/Cache/Response.html#method-i-expire-21","()","<p>Mark the response stale by setting the Age header to be equal to the\nmaximum age of the response.\n"],["expires","Rack::Cache::Response","Rack/Cache/Response.html#method-i-expires","()","<p>The value of the Expires header as a Time object.\n"],["fresh?","Rack::Cache::Response","Rack/Cache/Response.html#method-i-fresh-3F","()","<p>Determine if the response is “fresh”. Fresh responses may be served from\ncache without any …\n"],["generate","Rack::Cache::Key","Rack/Cache/Key.html#method-i-generate","()","<p>Generate a normalized cache key for the request.\n"],["get","Rack::Cache::AppEngine::MemCache","Rack/Cache/AppEngine/MemCache.html#method-i-get","(key)",""],["initialize_copy","Rack::Cache::Response","Rack/Cache/Response.html#method-i-initialize_copy","(other)",""],["instance","Rack::Cache::Storage","Rack/Cache/Storage.html#method-c-instance","()",""],["invalidate","Rack::Cache::MetaStore","Rack/Cache/MetaStore.html#method-i-invalidate","(request, entity_store)","<p>Invalidate all cache entries that match the request.\n"],["last_modified","Rack::Cache::Response","Rack/Cache/Response.html#method-i-last_modified","()","<p>The String value of the Last-Modified header exactly as it appears in the\nresponse (i.e., no date parsing …\n"],["lookup","Rack::Cache::MetaStore","Rack/Cache/MetaStore.html#method-i-lookup","(request, entity_store)","<p>Locate a cached response for the request provided. Returns a\nRack::Cache::Response object if the cache …\n"],["max_age","Rack::Cache::CacheControl","Rack/Cache/CacheControl.html#method-i-max_age","()","<p>The expiration time of an entity MAY be specified by the origin server\nusing the Expires header (see …\n"],["max_age","Rack::Cache::Response","Rack/Cache/Response.html#method-i-max_age","()","<p>The number of seconds after the time specified in the response’s Date\nheader when the the response should …\n"],["max_age=","Rack::Cache::Response","Rack/Cache/Response.html#method-i-max_age-3D","(value)","<p>The number of seconds after which the response should no longer be\nconsidered fresh. Sets the Cache- …\n"],["metastore","Rack::Cache::Context","Rack/Cache/Context.html#method-i-metastore","()","<p>The configured MetaStore instance. Changing the rack-cache.metastore value\neffects the result of this …\n"],["must_revalidate?","Rack::Cache::CacheControl","Rack/Cache/CacheControl.html#method-i-must_revalidate-3F","()","<p>Because a cache MAY be configured to ignore a server’s specified expiration\ntime, and because a client …\n"],["must_revalidate?","Rack::Cache::Response","Rack/Cache/Response.html#method-i-must_revalidate-3F","()","<p>Indicates that the cache must not serve a stale response in any\ncircumstance without first revalidating …\n"],["namespace","Rack::Cache::AppEngine::MemCache","Rack/Cache/AppEngine/MemCache.html#method-i-namespace","()",""],["namespace=","Rack::Cache::AppEngine::MemCache","Rack/Cache/AppEngine/MemCache.html#method-i-namespace-3D","(value)",""],["new","Rack::Cache","Rack/Cache.html#method-c-new","(backend, options={}, &b)","<p>Create a new Rack::Cache middleware component that fetches resources from\nthe specified backend application. …\n"],["new","Rack::Cache::AppEngine::MemCache","Rack/Cache/AppEngine/MemCache.html#method-c-new","(options = {})",""],["new","Rack::Cache::CacheControl","Rack/Cache/CacheControl.html#method-c-new","(value=nil)",""],["new","Rack::Cache::Context","Rack/Cache/Context.html#method-c-new","(backend, options={})",""],["new","Rack::Cache::EntityStore::Dalli","Rack/Cache/EntityStore/Dalli.html#method-c-new","(server=\"localhost:11211\", options={})",""],["new","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-c-new","(root)",""],["new","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-c-new","(root)",""],["new","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-c-new","(root)",""],["new","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-c-new","(options = {})",""],["new","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-c-new","(options = {})",""],["new","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-c-new","(options = {})",""],["new","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-c-new","(hash={})","<p>Create the store with the specified backing Hash.\n"],["new","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-c-new","(hash={})","<p>Create the store with the specified backing Hash.\n"],["new","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-c-new","(hash={})","<p>Create the store with the specified backing Hash.\n"],["new","Rack::Cache::EntityStore::MemCached","Rack/Cache/EntityStore/MemCached.html#method-c-new","(server=\"localhost:11211\", options={})",""],["new","Rack::Cache::Key","Rack/Cache/Key.html#method-c-new","(request)",""],["new","Rack::Cache::MetaStore::Dalli","Rack/Cache/MetaStore/Dalli.html#method-c-new","(server=\"localhost:11211\", options={})",""],["new","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-c-new","(root=\"/tmp/rack-cache/meta-#{ARGV[0]}\")",""],["new","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-c-new","(root=\"/tmp/rack-cache/meta-#{ARGV[0]}\")",""],["new","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-c-new","(root=\"/tmp/rack-cache/meta-#{ARGV[0]}\")",""],["new","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-c-new","(options = {})",""],["new","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-c-new","(options = {})",""],["new","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-c-new","(options = {})",""],["new","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-c-new","(hash={})",""],["new","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-c-new","(hash={})",""],["new","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-c-new","(hash={})",""],["new","Rack::Cache::MetaStore::MemCached","Rack/Cache/MetaStore/MemCached.html#method-c-new","(server=\"localhost:11211\", options={})",""],["new","Rack::Cache::Response","Rack/Cache/Response.html#method-c-new","(status, headers, body)","<p>Create a Response instance given the response status code, header hash, and\nbody.\n"],["new","Rack::Cache::Storage","Rack/Cache/Storage.html#method-c-new","()",""],["no_cache?","Rack::Cache::CacheControl","Rack/Cache/CacheControl.html#method-i-no_cache-3F","()","<p>When set in a response, a cache MUST NOT use the response to satisfy a\nsubsequent request without successful …\n"],["no_cache?","Rack::Cache::Request","Rack/Cache/Request.html#method-i-no_cache-3F","()","<p>True when the Cache-Control/no-cache directive is present or the Pragma\nheader is set to no-cache.\n"],["no_store?","Rack::Cache::CacheControl","Rack/Cache/CacheControl.html#method-i-no_store-3F","()","<p>Indicates that the response MUST NOT be stored under any circumstances.\n<p>The purpose of the no-store directive …\n"],["not_modified!","Rack::Cache::Response","Rack/Cache/Response.html#method-i-not_modified-21","()","<p>Modify the response so that it conforms to the rules defined for ‘304 Not\nModified’. This sets the status, …\n"],["open","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-open","(key)","<p>Open the entity body and return an IO object. The IO object’s each method\nis overridden to read 8K chunks …\n"],["open","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-open","(key)","<p>Open the entity body and return an IO object. The IO object’s each method\nis overridden to read 8K chunks …\n"],["open","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-open","(key)","<p>Open the entity body and return an IO object. The IO object’s each method\nis overridden to read 8K chunks …\n"],["open","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-open","(key)",""],["open","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-open","(key)",""],["open","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-open","(key)",""],["open","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-open","(key)","<p>Return an object suitable for use as a Rack response body for the specified\nkey.\n"],["open","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-open","(key)","<p>Return an object suitable for use as a Rack response body for the specified\nkey.\n"],["open","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-open","(key)","<p>Return an object suitable for use as a Rack response body for the specified\nkey.\n"],["open","Rack::Cache::EntityStore::MemCacheBase","Rack/Cache/EntityStore/MemCacheBase.html#method-i-open","(key)",""],["option_accessor","Rack::Cache::Options","Rack/Cache/Options.html#method-c-option_accessor","(key)",""],["option_name","Rack::Cache::Options","Rack/Cache/Options.html#method-c-option_name","(key)",""],["options","Rack::Cache::Options","Rack/Cache/Options.html#method-i-options","()","<p>The underlying options Hash. During initialization (or outside of a\nrequest), this is a default values …\n"],["options=","Rack::Cache::Options","Rack/Cache/Options.html#method-i-options-3D","(hash={})","<p>Set multiple options.\n"],["private=","Rack::Cache::Response","Rack/Cache/Response.html#method-i-private-3D","(value)","<p>Mark the response “private”, making it ineligible for serving other\nclients.\n"],["private?","Rack::Cache::CacheControl","Rack/Cache/CacheControl.html#method-i-private-3F","()","<p>Indicates that all or part of the response message is intended for a single\nuser and MUST NOT be cached …\n"],["proxy_revalidate?","Rack::Cache::CacheControl","Rack/Cache/CacheControl.html#method-i-proxy_revalidate-3F","()","<p>The proxy-revalidate directive has the same meaning as the must- revalidate\ndirective, except that it …\n"],["public?","Rack::Cache::CacheControl","Rack/Cache/CacheControl.html#method-i-public-3F","()","<p>Indicates that the response MAY be cached by any cache, even if it would\nnormally be non-cacheable or …\n"],["purge","Rack::Cache::EntityStore::Dalli","Rack/Cache/EntityStore/Dalli.html#method-i-purge","(key)",""],["purge","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-purge","(key)",""],["purge","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-purge","(key)",""],["purge","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-purge","(key)",""],["purge","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-purge","(key)",""],["purge","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-purge","(key)",""],["purge","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-purge","(key)",""],["purge","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-purge","(key)","<p>Remove the body corresponding to key; return nil.\n"],["purge","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-purge","(key)","<p>Remove the body corresponding to key; return nil.\n"],["purge","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-purge","(key)","<p>Remove the body corresponding to key; return nil.\n"],["purge","Rack::Cache::EntityStore::MemCached","Rack/Cache/EntityStore/MemCached.html#method-i-purge","(key)",""],["purge","Rack::Cache::MetaStore","Rack/Cache/MetaStore.html#method-i-purge","(key)","<p>Remove all cached entries at the key specified. No error is raised when the\nkey does not exist.\n"],["purge","Rack::Cache::MetaStore::Dalli","Rack/Cache/MetaStore/Dalli.html#method-i-purge","(key)",""],["purge","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-i-purge","(key)",""],["purge","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-i-purge","(key)",""],["purge","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-i-purge","(key)",""],["purge","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-i-purge","(key)",""],["purge","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-i-purge","(key)",""],["purge","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-i-purge","(key)",""],["purge","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-purge","(key)",""],["purge","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-purge","(key)",""],["purge","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-purge","(key)",""],["purge","Rack::Cache::MetaStore::MemCached","Rack/Cache/MetaStore/MemCached.html#method-i-purge","(key)",""],["put","Rack::Cache::AppEngine::MemCache","Rack/Cache/AppEngine/MemCache.html#method-i-put","(key, value, ttl = nil)",""],["read","Rack::Cache::EntityStore::Dalli","Rack/Cache/EntityStore/Dalli.html#method-i-read","(key)",""],["read","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-read","(key)",""],["read","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-read","(key)",""],["read","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-read","(key)",""],["read","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-read","(key)",""],["read","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-read","(key)",""],["read","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-read","(key)",""],["read","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-read","(key)","<p>Read all data associated with the given key and return as a single String.\n"],["read","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-read","(key)","<p>Read all data associated with the given key and return as a single String.\n"],["read","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-read","(key)","<p>Read all data associated with the given key and return as a single String.\n"],["read","Rack::Cache::EntityStore::MemCached","Rack/Cache/EntityStore/MemCached.html#method-i-read","(key)",""],["read","Rack::Cache::MetaStore","Rack/Cache/MetaStore.html#method-i-read","(key)","<p>Locate all cached request/response pairs that match the specified URL key.\nThe result must be an Array …\n"],["read","Rack::Cache::MetaStore::Dalli","Rack/Cache/MetaStore/Dalli.html#method-i-read","(key)",""],["read","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-i-read","(key)",""],["read","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-i-read","(key)",""],["read","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-i-read","(key)",""],["read","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-i-read","(key)",""],["read","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-i-read","(key)",""],["read","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-i-read","(key)",""],["read","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-read","(key)",""],["read","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-read","(key)",""],["read","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-read","(key)",""],["read","Rack::Cache::MetaStore::MemCached","Rack/Cache/MetaStore/MemCached.html#method-i-read","(key)",""],["request_method","Rack::Cache::Request","Rack/Cache/Request.html#method-i-request_method","()","<p>The HTTP request method. This is the standard implementation of this method\nbut is respecified here due …\n"],["resolve","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::EntityStore::MemCacheBase","Rack/Cache/EntityStore/MemCacheBase.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-c-resolve","(uri)",""],["resolve","Rack::Cache::MetaStore::MemCacheBase","Rack/Cache/MetaStore/MemCacheBase.html#method-c-resolve","(uri)","<p>Create MemCache store for the given URI. The URI must specify a host and\nmay specify a port, namespace, …\n"],["resolve_entitystore_uri","Rack::Cache::Storage","Rack/Cache/Storage.html#method-i-resolve_entitystore_uri","(uri)",""],["resolve_metastore_uri","Rack::Cache::Storage","Rack/Cache/Storage.html#method-i-resolve_metastore_uri","(uri)",""],["s_maxage","Rack::Cache::CacheControl","Rack/Cache/CacheControl.html#method-i-s_maxage","()",""],["set","Rack::Cache::Options","Rack/Cache/Options.html#method-i-set","(option, value=self, &block)","<p>Set an option. When <code>option</code> is a Symbol, it is set in the Rack\nEnvironment as “rack-cache.option …\n"],["shared_max_age","Rack::Cache::CacheControl","Rack/Cache/CacheControl.html#method-i-shared_max_age","()","<p>If a response includes an s-maxage directive, then for a shared cache (but\nnot for a private cache), …\n"],["shared_max_age=","Rack::Cache::Response","Rack/Cache/Response.html#method-i-shared_max_age-3D","(value)","<p>Like #max_age= but sets the s-maxage directive, which applies only to\nshared caches.\n"],["spread","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-spread","(key)",""],["spread","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-spread","(key)",""],["spread","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-spread","(key)",""],["storage_path","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-storage_path","(stem)",""],["storage_path","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-storage_path","(stem)",""],["storage_path","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-storage_path","(stem)",""],["store","Rack::Cache::MetaStore","Rack/Cache/MetaStore.html#method-i-store","(request, response, entity_store)","<p>Write a cache entry to the store under the given key. Existing entries are\nread and any that match the …\n"],["to_a","Rack::Cache::Response","Rack/Cache/Response.html#method-i-to_a","()","<p>Return the status, headers, and body in a three-tuple.\n"],["to_hash","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-to_hash","()",""],["to_hash","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-to_hash","()",""],["to_hash","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-to_hash","()",""],["to_s","Rack::Cache::CacheControl","Rack/Cache/CacheControl.html#method-i-to_s","()",""],["ttl","Rack::Cache::Response","Rack/Cache/Response.html#method-i-ttl","()","<p>The response’s time-to-live in seconds, or nil when no freshness\ninformation is present in the response. …\n"],["ttl=","Rack::Cache::Response","Rack/Cache/Response.html#method-i-ttl-3D","(seconds)","<p>Set the response’s time-to-live for shared caches to the specified number\nof seconds. This adjusts the …\n"],["validateable?","Rack::Cache::Response","Rack/Cache/Response.html#method-i-validateable-3F","()","<p>Determine if the response includes headers that can be used to validate the\nresponse with the origin …\n"],["vary","Rack::Cache::Response","Rack/Cache/Response.html#method-i-vary","()","<p>The literal value of the Vary header, or nil when no header is present.\n"],["vary?","Rack::Cache::Response","Rack/Cache/Response.html#method-i-vary-3F","()","<p>Does the response include a Vary header?\n"],["vary_header_names","Rack::Cache::Response","Rack/Cache/Response.html#method-i-vary_header_names","()","<p>An array of header names given in the Vary header or an empty array when no\nVary header is present.\n"],["write","Rack::Cache::EntityStore::Dalli","Rack/Cache/EntityStore/Dalli.html#method-i-write","(body, ttl=nil)",""],["write","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-write","(body, ttl=nil)",""],["write","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-write","(body, ttl=nil)",""],["write","Rack::Cache::EntityStore::Disk","Rack/Cache/EntityStore/Disk.html#method-i-write","(body, ttl=nil)",""],["write","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-write","(body, ttl=nil)",""],["write","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-write","(body, ttl=nil)",""],["write","Rack::Cache::EntityStore::GAEStore","Rack/Cache/EntityStore/GAEStore.html#method-i-write","(body, ttl=nil)",""],["write","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-write","(body, ttl=nil)","<p>Write the Rack response body immediately and return the SHA1 key.\n"],["write","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-write","(body, ttl=nil)","<p>Write the Rack response body immediately and return the SHA1 key.\n"],["write","Rack::Cache::EntityStore::Heap","Rack/Cache/EntityStore/Heap.html#method-i-write","(body, ttl=nil)","<p>Write the Rack response body immediately and return the SHA1 key.\n"],["write","Rack::Cache::EntityStore::MemCached","Rack/Cache/EntityStore/MemCached.html#method-i-write","(body, ttl=0)",""],["write","Rack::Cache::MetaStore","Rack/Cache/MetaStore.html#method-i-write","(key, negotiations)","<p>Store an Array of request/response pairs for the given key. Concrete\nimplementations should not attempt …\n"],["write","Rack::Cache::MetaStore::Dalli","Rack/Cache/MetaStore/Dalli.html#method-i-write","(key, entries)",""],["write","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-i-write","(key, entries)",""],["write","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-i-write","(key, entries)",""],["write","Rack::Cache::MetaStore::Disk","Rack/Cache/MetaStore/Disk.html#method-i-write","(key, entries)",""],["write","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-i-write","(key, entries)",""],["write","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-i-write","(key, entries)",""],["write","Rack::Cache::MetaStore::GAEStore","Rack/Cache/MetaStore/GAEStore.html#method-i-write","(key, entries)",""],["write","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-write","(key, entries)",""],["write","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-write","(key, entries)",""],["write","Rack::Cache::MetaStore::Heap","Rack/Cache/MetaStore/Heap.html#method-i-write","(key, entries)",""],["write","Rack::Cache::MetaStore::MemCached","Rack/Cache/MetaStore/MemCached.html#method-i-write","(key, entries)",""],["CHANGES","","CHANGES.html","","<p>## 1.2 / March 2012\n\n<pre>* Fix a cookie leak vulnerability effecting large numbers of Rails 3.x installs:\n ...</pre>\n"],["COPYING","","COPYING.html","","<p>Copyright © 2008 Ryan Tomayko &lt;tomayko.com/about&gt;\n<p>Permission is hereby granted, free of charge, …\n"],["README","","README.html","","<p>Rack::Cache\n<p>\n<p>Rack::Cache is suitable as a quick drop-in component to enable HTTP caching\nfor Rack-based …\n"],["TODO","","TODO.html","","<p>## 0.5\n\n<pre>- Document allow_revalidate and allow_reload options.\n- Support multiple memcache servers.\n- Purge/invalidate ...</pre>\n"]]}}