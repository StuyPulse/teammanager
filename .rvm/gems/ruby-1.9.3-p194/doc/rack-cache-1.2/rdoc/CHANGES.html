<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>CHANGES - rack-cache-1.2 Documentation</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body class="file">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="./CHANGES.html">CHANGES</a>
  
    <li class="file"><a href="./COPYING.html">COPYING</a>
  
    <li class="file"><a href="./README.html">README</a>
  
    <li class="file"><a href="./TODO.html">TODO</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./Rack.html">Rack</a>
  
    <li><a href="./Rack/Cache.html">Rack::Cache</a>
  
    <li><a href="./Rack/Cache/AppEngine.html">Rack::Cache::AppEngine</a>
  
    <li><a href="./Rack/Cache/AppEngine/MC.html">Rack::Cache::AppEngine::MC</a>
  
    <li><a href="./Rack/Cache/AppEngine/MemCache.html">Rack::Cache::AppEngine::MemCache</a>
  
    <li><a href="./Rack/Cache/CacheControl.html">Rack::Cache::CacheControl</a>
  
    <li><a href="./Rack/Cache/Context.html">Rack::Cache::Context</a>
  
    <li><a href="./Rack/Cache/EntityStore.html">Rack::Cache::EntityStore</a>
  
    <li><a href="./Rack/Cache/EntityStore/Disk.html">Rack::Cache::EntityStore::DISK</a>
  
    <li><a href="./Rack/Cache/EntityStore/Dalli.html">Rack::Cache::EntityStore::Dalli</a>
  
    <li><a href="./Rack/Cache/EntityStore/Disk.html">Rack::Cache::EntityStore::Disk</a>
  
    <li><a href="./Rack/Cache/EntityStore/Disk.html">Rack::Cache::EntityStore::FILE</a>
  
    <li><a href="./Rack/Cache/EntityStore/GAEStore.html">Rack::Cache::EntityStore::GAE</a>
  
    <li><a href="./Rack/Cache/EntityStore/GAEStore.html">Rack::Cache::EntityStore::GAECACHE</a>
  
    <li><a href="./Rack/Cache/EntityStore/GAEStore.html">Rack::Cache::EntityStore::GAEStore</a>
  
    <li><a href="./Rack/Cache/EntityStore/Heap.html">Rack::Cache::EntityStore::HEAP</a>
  
    <li><a href="./Rack/Cache/EntityStore/Heap.html">Rack::Cache::EntityStore::Heap</a>
  
    <li><a href="./Rack/Cache/EntityStore/Heap.html">Rack::Cache::EntityStore::MEM</a>
  
    <li><a href="./Rack/Cache/EntityStore/MemCacheBase.html">Rack::Cache::EntityStore::MemCacheBase</a>
  
    <li><a href="./Rack/Cache/EntityStore/MemCached.html">Rack::Cache::EntityStore::MemCached</a>
  
    <li><a href="./Rack/Cache/Key.html">Rack::Cache::Key</a>
  
    <li><a href="./Rack/Cache/MetaStore.html">Rack::Cache::MetaStore</a>
  
    <li><a href="./Rack/Cache/MetaStore/Disk.html">Rack::Cache::MetaStore::DISK</a>
  
    <li><a href="./Rack/Cache/MetaStore/Dalli.html">Rack::Cache::MetaStore::Dalli</a>
  
    <li><a href="./Rack/Cache/MetaStore/Disk.html">Rack::Cache::MetaStore::Disk</a>
  
    <li><a href="./Rack/Cache/MetaStore/Disk.html">Rack::Cache::MetaStore::FILE</a>
  
    <li><a href="./Rack/Cache/MetaStore/GAEStore.html">Rack::Cache::MetaStore::GAE</a>
  
    <li><a href="./Rack/Cache/MetaStore/GAEStore.html">Rack::Cache::MetaStore::GAECACHE</a>
  
    <li><a href="./Rack/Cache/MetaStore/GAEStore.html">Rack::Cache::MetaStore::GAEStore</a>
  
    <li><a href="./Rack/Cache/MetaStore/Heap.html">Rack::Cache::MetaStore::HEAP</a>
  
    <li><a href="./Rack/Cache/MetaStore/Heap.html">Rack::Cache::MetaStore::Heap</a>
  
    <li><a href="./Rack/Cache/MetaStore/Heap.html">Rack::Cache::MetaStore::MEM</a>
  
    <li><a href="./Rack/Cache/MetaStore/MemCacheBase.html">Rack::Cache::MetaStore::MemCacheBase</a>
  
    <li><a href="./Rack/Cache/MetaStore/MemCached.html">Rack::Cache::MetaStore::MemCached</a>
  
    <li><a href="./Rack/Cache/Options.html">Rack::Cache::Options</a>
  
    <li><a href="./Rack/Cache/Request.html">Rack::Cache::Request</a>
  
    <li><a href="./Rack/Cache/Response.html">Rack::Cache::Response</a>
  
    <li><a href="./Rack/Cache/Storage.html">Rack::Cache::Storage</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation" class="description">
  
<p>## 1.2 / March 2012</p>

<pre>* Fix a cookie leak vulnerability effecting large numbers of Rails 3.x installs:
  https://github.com/rtomayko/rack-cache/pull/52

* Never 304 on PUT or POST requests.

* Misc bundler and test tooling fixes.</pre>

<p>## 1.1 / September 2011</p>

<pre>* Allow (INM/IMS) validation requests through to backend on miss. Makes it
  possible to use validation for private / uncacheable responses. A number of
  people using Rails's stale?() helper reported that their validation logic was
  never kicking in.

* Add rack env rack-cache.force-pass option to bypass rack-cache on
  per request basis

* Fix an issue with memcache namespace not being set when using the
  :namespace option instead of :prefix_key.

* Fix test failures due to MockResponse changes in recent Rack
  version (issue #34)</pre>

<p>## 1.0.3 / August 2011</p>

<pre>* Fix bug passing options to memcached and dalli

* Document cache_key</pre>

<p>## 1.0.1 / April 2011</p>

<pre>* Added lib/rack-cache.rb to match package name for auto-requiring machinery.

* Fixed a number of issues caused by Rack::Cache not closing the body received
  from the application. Rack::Lock and other middleware use body.close to
  signal the true end of request processing so failure to call this method
  can result in strange issues (e.g.,
  &quot;ThreadError: deadlock; recursive locking&quot;)

* Fixed a bug where Rack::Cache would blow up writing the rack env to the meta
  store when the env contained an all uppercase key whose value wasn't
  marshalable. Passenger and some other stuff write such keys apparently.

* The test suite has moved from test-spec to bacon. This is a short term
  solution to the problem of not being able to run tests under Ruby 1.9.x.
  The test suite will be moved to basic Test::Unit style sometime in the
  future.</pre>

<p>## 1.0 / December 2010</p>

<pre>* Rack::Cache is 1.0 and will now maintain semantic versioning &lt;http://semver.org/&gt;

* Add Dalli memcache client support and removed support for the unmaintained
  memcache-client library. You will need to move your apps to Dalli before
  upgrading rack-cache to 1.0.</pre>

<p>## 0.5.3 / September 2010</p>

<pre>* A matching If-Modified-Since is ignored if an If-None-Match is also provided
  and doesn't match. This is in line with RFC 2616.

* Converts string status codes to integers before returns to workaround bad
  behaving rack middleware and apps.

* Misc doc clean up.</pre>

<p>## 0.5.2 / September 2009</p>

<pre>* Exceptions raised from the metastore are not fatal. This makes a lot of
  sense in most cases because its okay for the cache to be down - it
  shouldn't blow up your app.</pre>

<p>## 0.5.1 / June 2009</p>

<pre class="ruby">* <span class="ruby-constant">Added</span> <span class="ruby-identifier">support</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">memcached</span> <span class="ruby-identifier">clusters</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">other</span> <span class="ruby-identifier">advanced</span>
  <span class="ruby-identifier">configuration</span> <span class="ruby-identifier">provided</span> <span class="ruby-identifier">by</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">memcache</span><span class="ruby-operator">-</span><span class="ruby-identifier">client</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">memcached</span>
  <span class="ruby-identifier">libraries</span>. <span class="ruby-constant">The</span> <span class="ruby-string">&quot;metastore&quot;</span> <span class="ruby-keyword">and</span> <span class="ruby-string">&quot;entitystore&quot;</span> <span class="ruby-identifier">options</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">now</span> <span class="ruby-identifier">be</span>
  <span class="ruby-identifier">set</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">a</span> <span class="ruby-constant">MemCache</span> <span class="ruby-identifier">object</span> <span class="ruby-keyword">or</span> <span class="ruby-constant">Memcached</span> <span class="ruby-identifier">object</span><span class="ruby-operator">:</span>

  <span class="ruby-identifier">memcache</span> = <span class="ruby-constant">MemCache</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">'127.1.1.1'</span>, <span class="ruby-string">'127.1.1.2'</span>], :<span class="ruby-identifier">namespace</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;/foo&quot;</span>)
  <span class="ruby-identifier">use</span> <span class="ruby-constant">Rack</span><span class="ruby-operator">::</span><span class="ruby-constant">Cache</span>,
    :<span class="ruby-identifier">metastore</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">memcache</span>,
    :<span class="ruby-identifier">entitystore</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">memcache</span>

* <span class="ruby-constant">Fix</span> <span class="ruby-string">&quot;memcached://&quot;</span> <span class="ruby-identifier">metastore</span> <span class="ruby-constant">URL</span> <span class="ruby-identifier">handling</span>. <span class="ruby-constant">The</span> <span class="ruby-string">&quot;memcached&quot;</span> <span class="ruby-identifier">variation</span>
  <span class="ruby-identifier">blew</span> <span class="ruby-identifier">up</span>, <span class="ruby-identifier">the</span> <span class="ruby-string">&quot;memcache&quot;</span> <span class="ruby-identifier">version</span> <span class="ruby-identifier">was</span> <span class="ruby-identifier">fine</span>.
</pre>

<p>## 0.5.0 / May 2009</p>

<pre class="ruby">* <span class="ruby-constant">Added</span> <span class="ruby-identifier">meta</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">entity</span> <span class="ruby-identifier">store</span> <span class="ruby-identifier">implementations</span> <span class="ruby-identifier">based</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">the</span>
  <span class="ruby-identifier">memcache</span><span class="ruby-operator">-</span><span class="ruby-identifier">client</span> <span class="ruby-identifier">library</span>. <span class="ruby-constant">These</span> <span class="ruby-identifier">are</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">default</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">memcached</span>
  <span class="ruby-identifier">library</span> <span class="ruby-identifier">has</span> <span class="ruby-identifier">already</span> <span class="ruby-identifier">been</span> <span class="ruby-identifier">required</span>.

* <span class="ruby-constant">The</span> <span class="ruby-string">&quot;allow_reload&quot;</span> <span class="ruby-keyword">and</span> <span class="ruby-string">&quot;allow_revalidate&quot;</span> <span class="ruby-identifier">options</span> <span class="ruby-identifier">now</span> <span class="ruby-identifier">default</span> <span class="ruby-identifier">to</span>
  <span class="ruby-keyword">false</span> <span class="ruby-identifier">instead</span> <span class="ruby-identifier">of</span> <span class="ruby-keyword">true</span>. <span class="ruby-constant">This</span> <span class="ruby-identifier">means</span> <span class="ruby-identifier">we</span> <span class="ruby-keyword">break</span> <span class="ruby-identifier">with</span> <span class="ruby-constant">RFC</span> <span class="ruby-value">2616</span> <span class="ruby-identifier">out</span> <span class="ruby-identifier">of</span>
  <span class="ruby-identifier">the</span> <span class="ruby-identifier">box</span> <span class="ruby-identifier">but</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">expected</span> <span class="ruby-identifier">configuration</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">huge</span> <span class="ruby-identifier">majority</span>
  <span class="ruby-identifier">of</span> <span class="ruby-identifier">gateway</span> <span class="ruby-identifier">cache</span> <span class="ruby-identifier">scenarios</span>. <span class="ruby-constant">See</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">docs</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">configuration</span>
  <span class="ruby-identifier">options</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">more</span> <span class="ruby-identifier">information</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">these</span> <span class="ruby-identifier">options</span><span class="ruby-operator">:</span>
  <span class="ruby-identifier">http</span>:<span class="ruby-operator">/</span><span class="ruby-regexp">%rtomayko.com/</span><span class="ruby-identifier">rc</span><span class="ruby-operator">/</span><span class="ruby-identifier">rack</span><span class="ruby-operator">-</span><span class="ruby-identifier">cache</span><span class="ruby-operator">/</span><span class="ruby-identifier">configuration</span>

* <span class="ruby-constant">Added</span> <span class="ruby-constant">Google</span> <span class="ruby-constant">AppEngine</span> <span class="ruby-identifier">memcache</span> <span class="ruby-identifier">entity</span> <span class="ruby-identifier">store</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">metastore</span>
  <span class="ruby-identifier">implementations</span>. <span class="ruby-constant">To</span> <span class="ruby-identifier">use</span> <span class="ruby-constant">GAE</span><span class="ruby-string">'s memcache with rack-cache, set the
  &quot;metastore&quot; and &quot;entitystore&quot; options as follows:

      use Rack::Cache,
        :metastore   =&gt; '</span><span class="ruby-identifier">gae</span><span class="ruby-operator">:</span><span class="ruby-regexp">%r/</span><span class="ruby-identifier">cache</span><span class="ruby-operator">-</span><span class="ruby-identifier">meta</span><span class="ruby-string">',
        :entitystore =&gt; '</span><span class="ruby-identifier">gae</span><span class="ruby-operator">:</span><span class="ruby-regexp">%r/</span><span class="ruby-identifier">cache</span><span class="ruby-operator">-</span><span class="ruby-identifier">body</span><span class="ruby-string">'

  The '</span><span class="ruby-identifier">cache</span><span class="ruby-operator">-</span><span class="ruby-identifier">meta</span><span class="ruby-string">' and '</span><span class="ruby-identifier">cache</span><span class="ruby-operator">-</span><span class="ruby-identifier">body</span><span class="ruby-string">' parts are memcache namespace
  prefixes and should be set to different values.
</span></pre>

<p>## 0.4.0 / March 2009</p>

<pre>* Ruby 1.9.1 / Rack 1.0 compatible.

* Invalidate cache entries that match the request URL on non-GET/HEAD
  requests. i.e., POST, PUT, DELETE cause matching cache entries to
  be invalidated. The cache entry is validated with the backend using
  a conditional GET the next time it's requested.

* Implement &quot;Cache-Control: max-age=N&quot; request directive by forcing
  validation when the max-age provided exceeds the age of the cache
  entry. This can be disabled by setting the &quot;allow_revalidate&quot; option to
  false.

* Properly implement &quot;Cache-Control: no-cache&quot; request directive by
  performing a full reload. RFC 2616 states that when &quot;no-cache&quot; is
  present in the request, the cache MUST NOT serve a stored response even
  after successful validation. This is slightly different from the
  &quot;no-cache&quot; directive in responses, which indicates that the cache must
  first validate its entry with the origin. Previously, we implemented
  &quot;no-cache&quot; on requests by passing so no new cache entry would be stored
  based on the response. Now we treat it as a forced miss and enter the
  response into the cache if it's cacheable. This can be disabled by
  setting the &quot;allow_reload&quot; option to false.

* Assume identical semantics for the &quot;Pragma: no-cache&quot; request header
  as the &quot;Cache-Control: no-cache&quot; directive described above.

* Less crazy logging. When the verbose option is set, a single log entry
  is written with a comma separated list of trace events. For example, if
  the cache was stale but validated, the following log entry would be
  written: &quot;cache: stale, valid, store&quot;. When the verbose option is false,
  no logging occurs.

* Added &quot;X-Rack-Cache&quot; response header with the same comma separated trace
  value as described above. This gives some visibility into how the cache
  processed the request.

* Add support for canonicalized cache keys, as well as custom cache key
  generators, which are specified in the options as :cache_key as either
  any object that has a call() or as a block. Cache key generators get
  passed a request object and return a cache key string.</pre>

<p>## 0.3.0 / December 2008</p>

<pre>* Add support for public and private cache control directives. Responses
  marked as explicitly public are cached even when the request includes
  an Authorization or Cookie header. Responses marked as explicitly private
  are considered uncacheable.

* Added a &quot;private_headers&quot; option that dictates which request headers
  trigger default &quot;private&quot; cache control processing. By default, the
  Cookie and Authorization headers are included. Headers may be added or
  removed as necessary to change the default private logic.

* Adhere to must-revalidate/proxy-revalidate cache control directives by
  not assigning the default_ttl to responses that don't include freshness
  information. This should let us begin using default_ttl more liberally
  since we can control it using the must-revalidate/proxy-revalidate directives.

* Use the s-maxage Cache-Control value in preference to max-age when
  present. The ttl= method now sets the s-maxage value instead of max-age.
  Code that used ttl= to control freshness at the client needs to change
  to set the max-age directive explicitly.

* Enable support for X-Sendfile middleware by responding to #to_path on
  bodies served from disk storage. Adding the Rack::Sendfile component
  upstream from Rack::Cache will result in cached bodies being served
  directly by the web server (instead of being read in Ruby).

* BUG: MetaStore hits but EntityStore misses. This would 500 previously; now
  we detect it and act as if the MetaStore missed as well.

* Implement low level #purge method on all concrete entity store
  classes -- removes the entity body corresponding to the SHA1 key
  provided and returns nil.

* Basically sane handling of HEAD requests. A HEAD request is never passed
  through to the backend except when transitioning with pass!. This means
  that the cache responds to HEAD requests without invoking the backend at
  all when the cached entry is fresh. When no cache entry exists, or the
  cached entry is stale and can be validated, the backend is invoked with
  a GET request and the HEAD is handled right before the response
  is delivered upstream.

* BUG: The Age response header was not being set properly when a stale
  entry was validated. This would result in Age values that exceeded
  the freshness lifetime in responses.

* BUG: A cached entry in a heap meta store could be unintentionally
  modified by request processing since the cached objects were being
  returned directly. The result was typically missing/incorrect header
  values (e.g., missing Content-Type header). [dkubb]

* BUG: 304 responses should not include entity headers (especially
  Content-Length). This is causing Safari/WebKit weirdness on 304
  responses.

* BUG: The If-None-Match header was being ignored, causing the cache
  to send 200 responses to matching conditional GET requests.</pre>

<p>## 0.2.0 / 2008-10-24 / Initial Release</p>

<pre>* Document events and transitions in `rack/cache/config/default.rb`
* Basic logging support (`trace`, `warn`, `info`, `error` from within Context)
* EntityStore: store entity bodies keyed by SHA
* MetaStore: store response headers keyed by URL
* Last-Modified/ETag validation
* Vary support
* Implement error! transition
* New Rack::Cache::Core
* memcached meta and entity store implementations
* URI based storage configuration
* Read options from Rack env if present (rack-cache.XXX keys)
* `object` is now `entry`
* Documentation framework and website
* Document storage areas and implementations
* Document configuration/events</pre>

<p>## 0.1.0 / 2008-07-21 / Proof of concept (unreleased)</p>

<pre>* Basic core with event support
* `#import` method for bringing in config files
* Freshness based expiration
* RFC 2616 If-Modified-Since based validation
* A horribly shitty storage back-end (Hash in mem)
* Don't cache hop-by-hop headers: Connection, Keep-Alive, Proxy-Authenticate,
  Proxy-Authorization, TE, Trailers, Transfer-Encoding, Upgrade</pre>

</div>



<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

